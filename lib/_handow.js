'use strict';

/**
 * Handow APIs provider
 * @module _handow
 * @description The _handow module provide APIs for application integration, that's the Handow engine interface.
 * For example, the handow CLI call these APIs, the SHM server runner calls these APTs
 */
const appRoot = require("app-root-path");
const https = require('https');
const httpAgent = require('axios').create({
    httpsAgent: new https.Agent({
        rejectUnauthorized: false
    })
});
const fs = require('fs');
const util = require('util');
const path = require('path');
const glob = require('glob');
const _ = require('lodash');
const wfPromise = util.promisify(fs.writeFile);

const eventBus = require('./eventBus');
const planRunr = require('./planRunr');
const parseStory = require('./parseStory');
const buildSteps = require('./buildSteps');
const buildPlanTree = require('./buildPlanTree');
// const sleep = util.promisify(setTimeout);
const config = require('./planConfig').get();

let pjson;  // 2021-06-04, conditional import package.json // const pjson = require('../package.json');
try {
    pjson = require('../package.json');
} catch (err) {
    pjson = { version: "unknown" };
}

let shmSetting;     // SHM setting file located in appRoot for SHM server configuration
try {
    shmSetting = require(path.join(`${appRoot}`, 'shmSetting.json')); // import shm-setting if SHM installed
} catch (err) {
    shmSetting = null;    // null means no SHM server deployed in current handow project
}

let pTree = null;
let runningPlan = null;
let nativeRunPid = null;
let newArcRecord = null;
let isRunning = false;

/*
    The post-process after test finished, either normally or by exception.
 */
eventBus.on("HDW_TEST_FINISHED", () => {

    /*
        Handow engine communicate living SHM server with HTTP requests.
        Indicate SHM server (if possible exist) the "HDW_TEST_FINISHED" of native running
    */
    if (shmSetting && nativeRunPid) {
        httpAgent.request({
            url: "/handow/handowstatus",
            baseURL: `http://localhost:${shmSetting.httpPort}/api`,
            method: "POST",
            headers: { 'X-HANDOW-TOKEN': shmSetting.shmToken },
            data: { pid: null, running: false }
        })                  // This request will reset 'isRunning' status and clear the native-run processid
        .then( () => {} )
        .catch( (err) => {} );
    }

    /*
        Send event to reset the SHM server SSE status to "idle" if shm running finished
    */
    if (`${process.env["LOCAL_RUN"]}` !== 'true') {
        eventBus.emit("SSE_HANDOW_STREAM", {
            status: "idle"
        });
    }


    /*
        Reset running properties and status in case of "HDW_TEST_FINISHED", either native or shm running
    */
    pTree = null;
    runningPlan = null;
    isRunning = false;
    nativeRunPid = null;
  
    /*
        Handow use process.env save and pass global signals
    */
    process.env["HDW_BREAK"] = false;       // Reset process.env["HDW_BREAK"]
    process.env["LOCAL_RUN"] = false;       // Reset local run flag - process.env["HDW_BREAK"]
});

/**
 * @function runBuildTree Build plan tree API
 * @param {object} plan - the plan object, 'path' property of it specify the path of the plan file
 * @return {Promise} - the tree object (before tree return, the *.tree.json file is persisted sibling with plan or story)
 * @description Build the plan tree for SHM render "tree" and "burning". The plan tree is built automatically before each running, and could be built by SHM call.
 */
const runBuildTree = async (plan) => {
    const planTree = await buildPlanTree(plan);
    pTree = planTree;       // plan tree is cached in application context once it is created
    return planTree;
};

/**
 * @function runPlan Run plan API
 * @param {string} _plan The full path of the specific plan file
 * @param {number} wkrs 
 * @description The API to run a plan by specify plan file and parallel working workers.
 * The plan tree is built in 'runPaln' before call 'planRunr' to run the plan.
 * The newArcRecord (archive record) is generated by 'planRunr' after running finished, and it is left to app context.
 */
const runPlan = async (_plan, wkrs) => {

    /*
        Kill current native running immediately
    */
    if (nativeRunPid) {
        try {
            process.kill(nativeRunPid, 'SIGINT');
            nativeRunPid = null;
        } catch (err) { /* */ }
    }

    process.env["HDW_BREAK"] = false;       // Reset global "HDW_BREAK" signal

    try {
        // const plan = require(_plan);         !!!!!!!! Don't use "require" as file reader in run time !!!!!!!!!!! 
        const plan = JSON.parse( fs.readFileSync(_plan) );      // import JSON plan to object 
        plan['path'] = _plan;       // Add file path of the plan (it is the full path)
        
        /*
            Set plan tile, use file name as title if no title defined
        */
        plan["plan"] = path.basename(_plan).slice(0, -5);
        if (!plan["title"]) {
            plan["title"] = path.basename(_plan).slice(0, -5);
        }

        /*
            See explaination in the bottom of the file
        */
        runningPlan = plan;
        pTree = await runBuildTree(plan);       // 0407, build plan tree and set to handow status
        isRunning = true;

        const workers = Number.isInteger(wkrs) && wkrs > 0 ? wkrs : config.workers;

        /*
            Call planRunr to run the plan
        */
        newArcRecord = await planRunr(plan, pTree, workers);   // 0407, pass planTree to planRunr

    } catch (err) {
        /*
            Force terminate test running per exception, otherwise SHM server or shmui could be dead locked
        */
        eventBus.emit('HDW_TEST_FINISHED');

        if (err["code"] && err["code"] === "000") {
            return false;
        } else {
            return err.message;
        }
    }
};

/**
 * Run a story by wrapping it in a pan, so the virtual plan name is the story name.
 * 
 * @param {string} story - the full path of a story
 * @param {number} wkrs  - workers number
 */
const runStory = async (_story, wkrs) => {
    if (nativeRunPid) {
        try {
            process.kill(nativeRunPid, 'SIGINT');
            nativeRunPid = null;
        } catch (err) {
            //
        }
    }

    try {
        process.env["HDW_BREAK"] = false;
        const workers = Number.isInteger(wkrs) && wkrs > 0 ? wkrs : config.workers;

        // Actualy only one story in stories[]
        const stories = [];
        if (_story.endsWith(".feature")) {    // story path must be a .feature file
            stories.push(path.basename(_story).slice(0, -8));
        }

        if (stories.length > 0) {
            // Put stories to a single-stage plan, and then run it. The config will be the gloabl config
            const plan = {
                title: "Single stage plan for a story testing",
                path: `${_story}`,
                plan: `${stories.join()}`,
                stages: [
                    {
                        stage: "Test",
                        description: "Stories test with single stage plan",
                        stories: stories
                    }
                ],
                config: {
                    _testLocalJSON: true
                }
            };

            // ***Note: see buttom explanation ...
            runningPlan = plan;
            pTree = await runBuildTree(plan);       // 0407, build plan tree and set to handow status
            isRunning = true;
            // -----------------------------------

            newArcRecord = await planRunr(plan, pTree, workers);   // 0407

        } else {
            throw new TypeError(`No story found by path - ${_story}`);
        }
    } catch (e) {
        // !!!!Force terminate test running, otherwise shmui could be dead locked!!!!!!!
        eventBus.emit('HDW_TEST_FINISHED');

        return false;
    }

};

/**
 * SHM doesn't force to shut down handow running due to promise cancel issues.
 * Instead, it will trigger a flag: process.env["HDW_BREAK"], which will forbid handow continue current running and go to end normally.
 */
const stop = () => {
    process.env["HDW_BREAK"] = true;
    // eventBus.emit('STOP_RUNNING');
};

const runParseStories = async (_stories) => {
    if (_stories.endsWith(".feature")) {
        const storyName = path.basename(_stories).replace(".feature", ".json").trim();
        const suiteObj = parseStory(_stories);
        await wfPromise(path.join(path.dirname(_stories), storyName), JSON.stringify(suiteObj));
    } else {
        // all .feature files in this path
        const storyFiles = glob.sync(path.join(_stories, "/*.feature"));
        // Process each custom steps file and merge with built-in steps
        for (const file of storyFiles) {
            const storyName = path.basename(file).replace(".feature", ".json").trim();
            const suiteObj = parseStory(file);
            await wfPromise(path.join(path.dirname(file), storyName), JSON.stringify(suiteObj));
        }
    }
};

const runBuildSteps = async (customStepsPath) => {
    const _steps = await buildSteps(customStepsPath);
    if (_steps instanceof Error) {
        throw _steps;
    }
};

// Only SHM need get handowStatus because this is only called by SHM router API.
// When SHM access this method:
// if status is true or === 'status', just retrieve {newArcRecord: running: nativeRunPid:} (not including plan and tree)
const getHandowStatus = (_status) => {
    if (_status) {
        // the short version of handow status.
        return {
            newArcRecord: newArcRecord,
            running: isRunning,
            nativeRunPid: nativeRunPid,
            version: pjson.version
        };
    } else {
        return {
            newArcRecord: newArcRecord,
            running: isRunning,
            nativeRunPid: nativeRunPid,         // it is null with shm-running
            plan: runningPlan,      // null for native running
            tree: pTree             // null for native running
        };
    }

};

// This API is only called by SHM POST: /api/handow/handowstatus routes, set the native running pid.
const setRunningStatus = (pid) => {
    nativeRunPid = pid;
};


// Create direactoies for ste-bundles and report files
if (!fs.existsSync(path.join(`${config._rootPath}`, 'stepBundles'))) {
    fs.mkdirSync(path.join(`${config._rootPath}`, 'stepBundles'));
}
if (!fs.existsSync(path.join(`${config._rootPath}`, `${config.reportPath}`))) {
    fs.mkdirSync(path.join(`${config._rootPath}`, `${config.reportPath}`));
}
if (!fs.existsSync(path.join(`${config._rootPath}`, `${config.reportPath}`, 'archives'))) {
    fs.mkdirSync(path.join(`${config._rootPath}`, `${config.reportPath}`, 'archives'));
}

runBuildSteps();

module.exports = {
    eventBus: eventBus,
    runPlan: runPlan,
    runStory: runStory,
    stop: stop,
    parseStories: runParseStories,
    buildSteps: runBuildSteps,
    buildTree: runBuildTree,
    handowStatus: getHandowStatus,
    setRunningStatus: setRunningStatus     // Only called by http call from native running, set to process.id or null
};

/*
    setNativaRunPid() is used to maintain native-running process-id, set to native running process.pid on native running,
    reset to null when native running stopped
*/


/*
 * Explain the tricky of setting handowStaus.
 *
 * runningPlan = plan;
 * pTree = await runBuildTree(plan);
 * isRunning = true;
 *
 * These 3 lines set handow status to handow instance in CURRENT PROCESS. If current running is shm-running, it is okay.
 * SHMUI can access these data. However, native-running set them to its handow instance too, but the native-run instance licates
 * in other process than SHM-RUN. That means SHMUI couldn't get status of native-run because shm just access the handow of its process.
 *
 * In order to resolve this defect (make SHMUI knowing if native handow is running or not), the native-run will pass its process-id (pid)
 * to shm-run process if shm installed and launched. So that SHMUI will know handow running state even it is from native-run.
 *
 * SHM can not start another running until it finished or stopped from SHMUI. SHM can start without care about native-run, it will kill
 * the native-run process before sratup, that is why the pid is imprtant for SHM running.
 *
 * // 0407 changed ...
 * Pay attention: The native-run status passed to SHM context will not include "runningPlan" and "planTree". So the SHMUI can not see
 * the tree-burning for native-running. But SHMUI know native-run is running or not, and stop it automatically before SHM running
 */

