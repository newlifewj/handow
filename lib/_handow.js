'use strict';

/**
 * Handow APIs provider
 * @module _handow
 * @description The _handow module provide APIs for application integration, that's the Handow engine interface.
 * For example, the handow CLI call these APIs, the SHM server runner calls these APTs
 */
const appRoot = require("app-root-path");
const https = require('https');
const httpAgent = require('axios').create({
    httpsAgent: new https.Agent({
        rejectUnauthorized: false
    })
});
const fs = require('fs');
const util = require('util');
const path = require('path');
const glob = require('glob');
const _ = require('lodash');
const wfPromise = util.promisify(fs.writeFile);

const eventBus = require('./eventBus');
const planRunr = require('./planRunr');
const parseStory = require('./parseStory');
const buildSteps = require('./buildSteps');
const buildPlanTree = require('./buildPlanTree');
// const sleep = util.promisify(setTimeout);
const config = require('./planConfig').get();

let pjson;  // 2021-06-04, conditional import package.json // const pjson = require('../package.json');
try {
    pjson = require('../package.json');
} catch (err) {
    pjson = { version: "unknown" };
}

let shmSetting;     // SHM setting file located in appRoot for SHM server configuration
try {
    shmSetting = require(path.join(`${appRoot}`, 'shmSetting.json')); // import shm-setting if SHM installed
} catch (err) {
    shmSetting = null;    // null means no SHM server deployed in current handow project
}

let pTree = null;
let runningPlan = null;
let nativeRunPid = null;
let newArcRecord = null;
let isRunning = false;

/*
    The post-process after test finished, either normally or by exception.
 */
eventBus.on("HDW_TEST_FINISHED", () => {

    /*
        Handow engine communicate living SHM server with HTTP requests.
        Indicate SHM server (if possible exist) the "HDW_TEST_FINISHED" of native running
    */
    if (shmSetting && nativeRunPid) {
        httpAgent.request({
            url: "/handow/handowstatus",
            baseURL: `http://localhost:${shmSetting.httpPort}/api`,
            method: "POST",
            headers: { 'X-HANDOW-TOKEN': shmSetting.shmToken },
            data: { pid: null, running: false }
        })                  // This request will reset 'isRunning' status and clear the native-run processid
        .then( () => {} )
        .catch( (err) => {} );
    }

    /*
        Send event to reset the SHM server SSE status to "idle" if shm running finished
    */
    if (`${process.env["LOCAL_RUN"]}` !== 'true') {
        
        eventBus.emit("SSE_HANDOW_STREAM", {
            status: "idle"
        });
    }

    /*
        Reset running properties and status in case of "HDW_TEST_FINISHED", either native or shm running
    */
    pTree = null;
    runningPlan = null;
    isRunning = false;
    nativeRunPid = null;
  
    /*
        Handow use process.env save and pass global signals
    */
    process.env["HDW_BREAK"] = false;       // Reset process.env["HDW_BREAK"]
    process.env["LOCAL_RUN"] = false;       // Reset local run flag - process.env["HDW_BREAK"]

});

/**
 * @function runBuildTree Build plan tree API
 * @param {object} plan - the plan object, 'path' property of it specify the path of the plan file
 * @return {Promise} - the tree object (before tree return, the *.tree.json file is persisted sibling with plan or story)
 * @description Build the plan tree for SHM render "tree" and "burning". The plan tree is built automatically before each running, and could be built by SHM call.
 */
const runBuildTree = async (plan) => {
    const planTree = await buildPlanTree(plan);
    pTree = planTree;       // plan tree is cached in application context once it is created
    return planTree;
};

/**
 * @function runPlan Run plan API
 * @param {string} _plan The full path of the specific plan file
 * @return {*}
 * @description The API to run a plan by specify plan file and parallel working workers.
 * The plan tree is built in 'runPaln' before call 'planRunr' to run the plan.
 * The newArcRecord (archive record) is generated by 'planRunr' after running finished, and it is left to app context.
 */
const runPlan = async (_plan) => {

    /*
        Kill current native running immediately
    */
    if (nativeRunPid) {
        try {
            process.kill(nativeRunPid, 'SIGINT');
            nativeRunPid = null;
        } catch (err) { /* */ }
    }

    process.env["HDW_BREAK"] = false;       // Reset global "HDW_BREAK" signal

    try {
        // const plan = require(_plan);         !!!!!!!! Don't use "require" as file reader in run time !!!!!!!!!!! 
        const plan = JSON.parse( fs.readFileSync(_plan) );      // import JSON plan to object 
        plan['path'] = _plan;       // Add file path of the plan (it is the full path)
        
        /*
            Set plan tile, use file name as title if no title defined
        */
        plan["plan"] = path.basename(_plan).slice(0, -5);
        if (!plan["title"]) {
            plan["title"] = path.basename(_plan).slice(0, -5);
        }

        /*
            See explaination in the bottom of the file
        */
        runningPlan = plan;
        pTree = await runBuildTree(plan);       // 0407, build plan tree and set to handow status
        isRunning = true;

        // Todo: Validate plan and planTree, breakout if they are not valid.

        /*
            Call planRunr to run the plan
        */
        newArcRecord = await planRunr(plan, pTree );   // 0407, pass planTree to planRunr

    } catch (err) {
        /*
            Force terminate test running per exception, otherwise SHM server or shmui could be dead locked
        */
        eventBus.emit('HDW_TEST_FINISHED');

        if (err["code"] && err["code"] === "000") {
            return false;
        } else {
            return err.message;
        }
    }
};

/**
 * @function runStory Run story API
 * @param {string} story The full path of a story
 * @return {*}
 * @description Create a temporary plan wrapping the story and run the plan
 */
const runStory = async ( _story ) => {
    /*
        Kill current native running immediately
    */
        if (nativeRunPid) {
            try {
                process.kill(nativeRunPid, 'SIGINT');
                nativeRunPid = null;
            } catch (err) { /* */ }
        }
    
        process.env["HDW_BREAK"] = false;       // Reset global "HDW_BREAK" signal

    try {

        const stories = [];
        if (_story.endsWith(".feature")) {    // story path must be a .feature file
            stories.push(path.basename(_story).slice(0, -8));
        }

        /*
            Put stories to a single-stage plan, and then run it.
        */
        if (stories.length > 0) {
            const plan = {
                title: "Single stage plan for a story testing",
                path: `${_story}`,
                plan: `${stories.join()}`,
                stages: [
                    {
                        stage: "Test",
                        description: "Stories test with single stage plan",
                        stories: stories
                    }
                ],
                config: {}
            };

            runningPlan = plan;
            pTree = await runBuildTree(plan);
            isRunning = true;

            /* The new archived record leaf-path, e.g. "fullPlan.plan_1622865194259", !!! not the latest report !!! */
            newArcRecord = await planRunr(plan, pTree);

        } else {
            throw new TypeError(`No story found by path - ${_story}`);
        }
    } catch (e) {
        // ToDo: Exception here if playwright cannot install browser well, should send message to UI 
        eventBus.emit('HDW_TEST_FINISHED');
        return false;
    }
};

/**
 * @function stop Stop running API
 * @description SHM doesn't force to shut down handow running due to promise cancel issues.
 * Instead it sets process.env["HDW_BREAK"], which will forbid handow continue current running and go to end normally after a step finished.
 */
const stop = () => {
    process.env["HDW_BREAK"] = true;
};

/**
 * @function runParseStories Parse stories API
 * @param {string} _stories The full path of the specific story file or a path contain stories
 * @description Parse one or multiple stories into JSON objects, and save the JSON format stories sibling with the story feature files
 */
const runParseStories = async (_stories) => {
    if (_stories.endsWith(".feature")) {
        const storyName = path.basename(_stories).replace(".feature", ".json").trim();
        const suiteObj = parseStory(_stories);
        await wfPromise(path.join(path.dirname(_stories), storyName), JSON.stringify(suiteObj));
    } else {
        // all .feature files in this path
        const storyFiles = glob.sync(path.join(_stories, "/*.feature"));
        // Process each custom steps file and merge with built-in steps
        for (const file of storyFiles) {
            const storyName = path.basename(file).replace(".feature", ".json").trim();
            const suiteObj = parseStory(file);
            await wfPromise(path.join(path.dirname(file), storyName), JSON.stringify(suiteObj));
        }
    }
};

/**
 * @function runBuildSteps Rebuild all steps
 * @param {string} customStepsPath 
 * @description Rebuild all steps into act and fact bundles, including built-in and custom steps.
 */
const runBuildSteps = async (customStepsPath) => {
    const _steps = await buildSteps(customStepsPath);
    if (_steps instanceof Error) {
        throw _steps;
    }
};

/**
 * @function getHandowStatus Get status of the handow engine
 * @param {*} _status Specify the "type" of status, undefined or false means get the full status, otherwise return the simplified status (without plan and tree)
 * @returns {object} The status object
 */
const getHandowStatus = (_status) => {
    if (_status) {
        /* The simplified status */
        return {
            newArcRecord: newArcRecord,     // string, The new archived record leaf-path
            running: isRunning,             // boolean, true === running, otherwise the engine is idle
            nativeRunPid: nativeRunPid,     // *, the native running process-id if handow-core is running locally, null === no native running process
            version: pjson.version          // string, the version of the handow-core package
        };
    } else {
        return {
            newArcRecord: newArcRecord,
            running: isRunning,
            nativeRunPid: nativeRunPid,
            version: pjson.version,
            plan: runningPlan,              // object, the running plan object, null for native running or idle
            tree: pTree                     // object, the planTree of current running plan, null for native running or idle
        };
    }

};

/**
 * @function setRunningStatus Set status by native running
 * @param {string} pid Current locall running process id
 * @description This API will be called by SHM route handler when native running use POST request indicating SHM its process id
 */
const setRunningStatus = (pid) => {
    nativeRunPid = pid;
};

/*
    Module init block - generate required directories if they are not existed
*/
if (!fs.existsSync(path.join(`${config._rootPath}`, 'stepBundles'))) {
    fs.mkdirSync(path.join(`${config._rootPath}`, 'stepBundles'));
}
if (!fs.existsSync(path.join(`${config._rootPath}`, `${config.reportPath}`))) {
    fs.mkdirSync(path.join(`${config._rootPath}`, `${config.reportPath}`));
}
if (!fs.existsSync(path.join(`${config._rootPath}`, `${config.reportPath}`, 'archives'))) {
    fs.mkdirSync(path.join(`${config._rootPath}`, `${config.reportPath}`, 'archives'));
}

/*
    Module init block - rebuild steps automatically when APIs are initialized
*/
runBuildSteps();

/** Exports all functions */
module.exports = {
    eventBus: eventBus,
    runPlan: runPlan,
    runStory: runStory,
    stop: stop,
    parseStories: runParseStories,
    buildSteps: runBuildSteps,
    buildTree: runBuildTree,
    handowStatus: getHandowStatus,
    setRunningStatus: setRunningStatus
};

/*
 * Explain the tricky of setting handowStaus.
 *
 * runningPlan = plan;
 * pTree = await runBuildTree(plan);
 * isRunning = true;
 *
 * These 3 lines set handow status to handow instance in CURRENT PROCESS. If current running is shm-running, it is okay.
 * SHMUI can access these data. However, native-running set them to its handow instance too, but the native-run instance licates
 * in other process than SHM-RUN. That means SHMUI couldn't get status of native-run because shm just access the handow of its process.
 *
 * In order to resolve this defect (make SHMUI knowing if native handow is running or not), the native-run will pass its process-id (pid)
 * to shm-run process if shm installed and launched. So that SHMUI will know handow running state even it is from native-run.
 *
 * SHM can not start another running until it finished or stopped from SHMUI. SHM can start without care about native-run, it will kill
 * the native-run process before sratup, that is why the pid is imprtant for SHM running.
 *
 * // 0407 changed ...
 * Pay attention: The native-run status passed to SHM context will not include "runningPlan" and "planTree". So the SHMUI can not see
 * the tree-burning for native-running. But SHMUI know native-run is running or not, and stop it automatically before SHM running
 */

