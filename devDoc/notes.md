# Handow Developing Notes

## To-Do

Handow need CLI inteface

    # built stories
    > handow build

    # specify the path of a plan, e.g. "/plans/accessing-uat.plan.json", and run it
    > handow run [plan]

    # build stories and then run a plan
    > handow build run [plan]

    # run a single story by specify the .js story path, e.g. "/suites/UserProfile.js"
    > handow story [story]

Before adding handow CLI, we run it with npm

    > npm run handow --[plan]
    > npm run story --[]





## Vocabulary

+ **Plan**
+ **Stage**
+ **Story** - A BDD story file written with _**Given-When-Then**_ syntax, also called as **Literal Suite**. A story always contain one **Literal Suite**.
+ **phase**
+ **Literal Suite** - Textual description for a test procedure, normally for a closely related UI partial or a functional operation flow. Always start with a **Given** and followed by conditional **When** phases.
+ **Program Suite** - An executable test suite - a Jest _describe_ function. The **Literal Suites** are compiled into **Program Suites**.
+ **JSON Suite** - The intermediate state between a **Literal Suite** and the **Program Suite**. Before compilation, **Handow** will parse stories and transform them to JSON objects. The suite compiler can only process **JSON Suites** actually.
+ **Step** - In BDD _**Given-When-Then**_ story, each statement is a test step. In script code, a step is a function accessing the UI or other web resource, e.g. an URL, local storage ... There are 2 types of step, **Action** and **Verify**. All **Then** statements are **Verify** steps, others are **Action** steps.

> When we say **story**, means story file or the literal-suite in it. When we say **suite**, always means the **program-suite** generated by Handow, including **Dummy Suite** and **Real Suite**.

## Sequential and Parallel

Stages are sequential, stories (suites) in a stage are executed in parallel, phases in a story are executed sequentially.

## General

**Handow** is an e2e test framework for testing web applications, normally used as UAT. It is scaffolded with **Jest** and **Puppeteer**.

### Why named "Handow"

Users use **Puppeteer** writing e2e test on Chrome browser. It is a great help for sure, but sometimes we still want working a little bit easier. Just like the Puppeteer is a little weary of using those puppets, and even boring prepare the theatre. So he will think why don't just play hand shadow? 

### How to use Handow

#### Gnerate program test suites

The core of **Handow** is test suite process and compiler. User can write literal BDD stories with _**Given-When-Then**_ syntax, and **Handow** can gnerate program suites according literal suites and configuration. 2 types of program suite are generated, **Dummy Suite** and **Real Suite**. We will discuss the details later.

#### Arrange test running by plan

#### Presenting report

(web socket for real time test mornitor)

#### Standard steps and custom steps

Handow will refer **Step Library** in suite compile process. Literal steps will be compiled to **Real Suites** if they are instances in **Step Library**.

## Compile literal suites

+ 2 compile mode, **override** and **update**, **update** is the default mode.
+ Once **override** mode is specified, all JSON suite object and program suites are re-generated.
+ The important issue is **How To Merge New Changes With Existed Program Suites** in updating compilation.

### Updating Program Suites

Handow will parse stories to JSON objects. 

+ Compiler generate **Step Catalog** according to traversal all **JSON Suite**. For each step of a JSON suite, Handow will check current **Step Catalog** to see if it is already generated.
+ **Step Catalog** make it possible to reuse steps.
+ Steps in **Step Catalog** are indexed by step label, e.g. "when_i_click_add_book_button".
+ If Handow can not find step lable in current **Step Catalog** for a step-statement in a story, a new label will be created and point to a **Dummy Step**.
+ User can work arround **Dummy Step** to make it to **Real Step**.
+ When the same step statements are used in literal suites, the same statements will be compiled into the same step in **Step Catalog**.

### Reuse Steps in Step-Catalog

+ Step label is exactly same.
+ The parameters are exactly same.

### What is the relationship between Standard Step Lib, Custom Steps and Step catalog

If a step-reference-key was specified in step statement, this relevent step in Step Catlogue will be instantited as **Real Step** directly. Otherwise a **Dummy Step** is generated and user need to instantiate it manually.

In the final compile process, just fill suite template with steps from Step-Catalog

## JSON suite format

```js
    {
        "given": {
            "actions": [ /* step objects */ ],
            "facts": [ /* step objects */ ]
        },
        "whens": [
            {
                "actions": [ /* step objects */ ],
                "facts": [ /* step objects */ ]
            }
        ]
    }
```

The format of **step-object**, this is critical for Handow.

```js
{
    "label": "when_i_click_the_button_with_id",
    "params": [ "id", "delay" ],
    "type": "actions"
}
```

### Step Catalog

Step Catalog is the core resources of Handow. Handow compiler works in an easy way - **just fill the suite template with steps code**. And the steps code come from **Step Catalog**.

#### Step Catalog is generated

After a JSON suite was created by parsing a story, Handow will examine all steps in it to see if they existed in **Step Catalog**. If no step in Step Catalog matched JSON Suite step exactly (same label with same params), Handow will add a Dummy Step to Step Catalog.

## Handow for UAT

The UAT identify what customer concern about - behavior and appearance when users interact with browser. As a matter of fact, customers don't care about the data structure, code logic and API communication instead they focus on the E2E result. The **Duck Test** theory make sense, everything should be okay if the final result is good. 

> Of course programers can deploy more tests other than the UAT - if they can help coding and trouble shooting. But that is not necessary or worth to add too much when UAT has cover those features.

**From Report UI, we can also refer steps and suite online.**

## Console output

+ Suites are separated with "**** Foo Story ****".
+ Phases (**When** pahses) are 4 characters indent and saperated with "====>> phase title" on top.
+ If the **When** pahses are looped, the looping blocks are sapertead with "----".
+ If **Given** is looped (whole story looping), the looping blocks are saperated with "********".

## Handow and Cumcuber/Gerkin

Handow implement a sub set of Gerkin syntax, but not obey the Gerkin completly, much more simpler.

+ The **Given, When, Then** keywords (together with **And** and **But**).
+ The **#** keyword for comment in story file.
+ The **@** mark, including **@parameters:, @skip:** for parameters, looping and conditional.

## Parse story file

+ Use eachline read story file line by line.
+ Ignore comment lines, ignore empty lines
+ for @skip and @parameters, we need convert them to **a signle line**
+ How to identify parameters array or object?
+ We get a string array of each line
+ Then we can process the array with code.

## Puppeteer v5.2.1 issue

+ When we use pptr-v5.2.1 in { headless: false }
+ And I run story local_nav.feature
+ Then I get "[Error: EPERM: operation not permitted, unlink  ...]" and cannot finished story running normally.
+ And I cannot see the static render presenting the report view
+ And I can see the Chromium instance still live through window's Task Manager
+ And I see 'C:\Users\newli\AppData\Local\Temp\puppeteer_dev_chrome_profile-Gb0hcO\CrashpadMetrics-active.pma', which is locked by the unclosed chrimium instance.

That's a serious problem. I cannot imstall puppeteer again (Error -4048, cannot DELETE the puppeteer stuffs) until delete the CrashpadMetrics-active.pma files manually.
